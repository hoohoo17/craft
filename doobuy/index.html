<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë‘ë°”ì´ ì´ˆì½œë › ëŸ¬ì‹œ</title>
  <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --chocolate: #4a2c2a;
      --chocolate-dark: #2d1b1a;
      --chocolate-light: #6b4423;
      --gold: #d4af37;
      --gold-light: #f4d03f;
      --cream: #f5e6d3;
      --cream-dark: #e8d4bc;
      --pistachio: #93c572;
      --lemon: #fff44f;
      --grapefruit: #ff6b6b;
      --kadaif: #daa520;
    }

    body {
      font-family: 'Noto Sans KR', sans-serif;
      background: linear-gradient(135deg, var(--cream) 0%, var(--cream-dark) 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    #game-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      display: none;
    }

    #start-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
      padding: 20px;
    }

    #start-screen h1 {
      font-family: 'Black Han Sans', sans-serif;
      font-size: 4rem;
      color: var(--chocolate);
      text-shadow: 4px 4px 0 var(--gold);
      margin-bottom: 20px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #start-screen .subtitle {
      font-size: 1.5rem;
      color: var(--chocolate-light);
      margin-bottom: 40px;
    }

    .start-btn {
      font-family: 'Black Han Sans', sans-serif;
      font-size: 2rem;
      padding: 20px 60px;
      background: linear-gradient(180deg, var(--gold-light) 0%, var(--gold) 100%);
      border: 4px solid var(--chocolate);
      border-radius: 20px;
      cursor: pointer;
      color: var(--chocolate);
      box-shadow: 0 6px 0 var(--chocolate-dark);
      transition: all 0.1s;
    }

    .start-btn:hover {
      transform: translateY(2px);
      box-shadow: 0 4px 0 var(--chocolate-dark);
    }

    .start-btn:active {
      transform: translateY(6px);
      box-shadow: 0 0 0 var(--chocolate-dark);
    }

    #notification-bar {
      background: var(--chocolate-dark);
      color: var(--gold-light);
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 1.2rem;
      font-weight: bold;
      text-align: center;
      margin-bottom: 20px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
    }

    #status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--chocolate);
      color: var(--cream);
      padding: 15px 25px;
      border-radius: 10px;
      margin-bottom: 20px;
      font-weight: bold;
      flex-wrap: wrap;
      gap: 10px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #game-area {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 20px;
    }

    #customer-section {
      background: white;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    #customer-section h2 {
      font-family: 'Black Han Sans', sans-serif;
      color: var(--chocolate);
      margin-bottom: 15px;
      font-size: 1.3rem;
    }

    #customer-queue {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 180px;
      overflow-y: auto;
    }

    .customer-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--cream);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      border: 3px solid transparent;
    }

    .customer-item:hover {
      background: var(--cream-dark);
    }

    .customer-item.selected {
      border-color: var(--gold);
      background: var(--gold-light);
    }

    .customer-icons {
      font-size: 1.3rem;
    }

    .customer-info {
      font-size: 0.85rem;
      color: var(--chocolate);
    }

    #order-section {
      margin-top: 15px;
    }

    #order-section h3 {
      font-family: 'Black Han Sans', sans-serif;
      color: var(--chocolate);
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    #order-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 200px;
      overflow-y: auto;
    }

    .order-item {
      padding: 8px 10px;
      background: var(--cream);
      border-radius: 8px;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .order-item:hover {
      border-color: var(--chocolate-light);
    }

    .order-item.cooking {
      background: var(--gold-light);
      border-color: var(--gold);
    }

    .order-item.completed {
      background: var(--pistachio);
      opacity: 0.7;
      cursor: default;
    }

    .order-item.failed {
      background: var(--grapefruit);
      opacity: 0.7;
      cursor: default;
    }

    .order-status {
      font-size: 1.1rem;
    }

    #cooking-section {
      background: white;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    #cooking-section h2 {
      font-family: 'Black Han Sans', sans-serif;
      color: var(--chocolate);
      margin-bottom: 15px;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #cooking-count {
      font-size: 1rem;
      background: var(--gold);
      color: var(--chocolate);
      padding: 2px 10px;
      border-radius: 10px;
    }

    #cooking-slots {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 15px;
      max-height: 500px;
      overflow-y: auto;
      padding: 5px;
    }

    .cooking-slot {
      background: var(--cream);
      border-radius: 12px;
      padding: 15px;
      border: 3px solid var(--cream-dark);
    }

    .cooking-slot.active {
      border-color: var(--gold);
    }

    .slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-weight: bold;
      color: var(--chocolate);
      font-size: 0.9rem;
    }

    .slot-cancel {
      background: var(--grapefruit);
      color: white;
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .slot-steps {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }

    .mini-step {
      flex: 1;
      height: 30px;
      background: white;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }

    .mini-step.completed {
      background: var(--pistachio);
    }

    .mini-step.active {
      background: var(--gold-light);
      border-color: var(--gold);
      animation: minipulse 0.8s infinite;
    }

    .mini-step.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    @keyframes minipulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .slot-progress {
      height: 6px;
      background: white;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .slot-progress-fill {
      height: 100%;
      background: var(--gold);
      width: 0%;
      transition: width 0.1s linear;
    }

    .slot-topping {
      display: flex;
      gap: 5px;
      justify-content: center;
    }

    .slot-topping.hidden {
      display: none;
    }

    .mini-topping {
      padding: 5px 10px;
      border: 2px solid var(--chocolate);
      border-radius: 8px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mini-topping.kadaif { background: var(--kadaif); }
    .mini-topping.lemon { background: var(--lemon); }
    .mini-topping.grapefruit { background: var(--grapefruit); color: white; }

    .mini-topping:hover {
      transform: scale(1.1);
    }

    .slot-serve {
      display: none;
      width: 100%;
      padding: 8px;
      background: var(--pistachio);
      border: 2px solid var(--chocolate);
      border-radius: 8px;
      font-family: 'Black Han Sans', sans-serif;
      font-size: 0.9rem;
      cursor: pointer;
      margin-top: 10px;
    }

    .slot-serve.show {
      display: block;
    }

    .empty-slot-message {
      color: #999;
      text-align: center;
      padding: 40px;
      font-style: italic;
    }

    .result-toast {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      padding: 20px 40px;
      border-radius: 15px;
      font-family: 'Black Han Sans', sans-serif;
      font-size: 2rem;
      z-index: 1000;
      animation: toastPop 0.8s forwards;
    }

    @keyframes toastPop {
      0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
      20% { opacity: 1; transform: translateX(-50%) scale(1.2); }
      40% { transform: translateX(-50%) scale(1); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
    }

    .result-toast.good {
      background: var(--pistachio);
      color: var(--chocolate);
    }

    .result-toast.bad {
      background: var(--grapefruit);
      color: white;
    }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }

    #summary-screen {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 1000;
      min-width: 350px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }

    #summary-screen h2 {
      font-family: 'Black Han Sans', sans-serif;
      color: var(--chocolate);
      font-size: 1.8rem;
      margin-bottom: 20px;
    }

    .summary-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid var(--cream-dark);
      font-size: 1.1rem;
    }

    .summary-total {
      font-family: 'Black Han Sans', sans-serif;
      font-size: 1.8rem;
      color: var(--gold);
      margin-top: 20px;
    }

    #next-day-btn {
      margin-top: 25px;
      font-family: 'Black Han Sans', sans-serif;
      font-size: 1.2rem;
      padding: 12px 35px;
      background: var(--chocolate);
      color: var(--cream);
      border: none;
      border-radius: 15px;
      cursor: pointer;
    }

    #next-day-btn:hover {
      background: var(--chocolate-light);
    }

    #gameover-screen {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(180deg, var(--chocolate) 0%, var(--chocolate-dark) 100%);
      padding: 50px;
      border-radius: 20px;
      text-align: center;
      z-index: 1000;
      min-width: 400px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }

    #gameover-screen h2 {
      font-family: 'Black Han Sans', sans-serif;
      color: var(--gold);
      font-size: 2.2rem;
      margin-bottom: 25px;
    }

    .final-stats {
      color: var(--cream);
      font-size: 1.2rem;
      margin-bottom: 8px;
    }

    #restart-btn {
      margin-top: 25px;
      font-family: 'Black Han Sans', sans-serif;
      font-size: 1.3rem;
      padding: 15px 40px;
      background: var(--gold);
      color: var(--chocolate);
      border: none;
      border-radius: 15px;
      cursor: pointer;
    }

    #restart-btn:hover {
      background: var(--gold-light);
    }

    .empty-message {
      color: #999;
      text-align: center;
      padding: 20px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div id="start-screen">
    <h1>ğŸ« ë‘ë°”ì´ ì´ˆì½œë › ëŸ¬ì‹œ ğŸ«</h1>
    <p class="subtitle">ë‹¬ì½¤í•œ ë‘ë°”ì´ ì´ˆì½œë › ê°€ê²Œë¥¼ ìš´ì˜í•˜ì„¸ìš”!</p>
    <button class="start-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
  </div>

  <div id="game-container">
    <div id="notification-bar">ğŸ”” ê°€ê²Œ ì˜¤í”ˆ ì¤€ë¹„ ì¤‘...</div>

    <div id="status-bar">
      <div class="status-item"><span>ğŸ“…</span><span id="day-display">ì›”ìš”ì¼</span></div>
      <div class="status-item"><span>ğŸ•</span><span id="period-display">ì˜¤ì „</span></div>
      <div class="status-item"><span>ğŸ’°</span><span id="money-display">0ì›</span></div>
      <div class="status-item"><span>ğŸ‘</span><span id="good-display">0</span></div>
      <div class="status-item"><span>ğŸ‘</span><span id="bad-display">0</span></div>
    </div>

    <div id="game-area">
      <div id="customer-section">
        <h2>ğŸ‘¥ ëŒ€ê¸° ì†ë‹˜</h2>
        <div id="customer-queue"></div>
        <div id="order-section">
          <h3>ğŸ“‹ ì£¼ë¬¸ì„œ</h3>
          <div id="order-list"></div>
        </div>
      </div>

      <div id="cooking-section">
        <h2>ğŸ³ ì¡°ë¦¬ëŒ€ <span id="cooking-count">0ê°œ ì¡°ë¦¬ì¤‘</span></h2>
        <div id="cooking-slots">
          <div class="empty-slot-message">ì£¼ë¬¸ì„ í´ë¦­í•´ì„œ ì¡°ë¦¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”</div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay"></div>

  <div id="summary-screen">
    <h2>ğŸ“Š ì¼ì¼ ì •ì‚°</h2>
    <div id="summary-content"></div>
    <button id="next-day-btn" onclick="nextDay()">ë‹¤ìŒ ë‚ ë¡œ</button>
  </div>

  <div id="gameover-screen">
    <h2>ğŸ‰ í•œ ì£¼ ì™„ë£Œ!</h2>
    <div id="final-stats"></div>
    <button id="restart-btn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <script>
    const CONFIG = {
      MAX_COOKING_SLOTS: 100,
      MENU: {
        kadaif: { name: 'ë‘ë°”ì´ ì´ˆì½œë ›', topping: 'kadaif', price: 5 },
        lemon: { name: 'ë ˆëª¬ ë‘ë°”ì´ ì´ˆì½œë ›', topping: 'lemon', price: 5 },
        grapefruit: { name: 'ìëª½ ë‘ë°”ì´ ì´ˆì½œë ›', topping: 'grapefruit', price: 5 }
      },
      TOPPING_NAMES: { kadaif: 'ì¹´ë‹¤ì´í”„', lemon: 'ë ˆëª¬', grapefruit: 'ìëª½' },
      STEPS: [
        { name: 'ë…¹ì´ê¸°', icon: 'ğŸ«', timed: false },
        { name: 'ë¶“ê¸°', icon: 'ğŸ«—', timed: false },
        { name: 'ëƒ‰ë™', icon: 'ğŸ§Š', timed: true, duration: 3000 },
        { name: 'ë³¶ê¸°', icon: 'ğŸ³', timed: true, duration: 1000, needsTopping: true },
        { name: 'ì„ê¸°', icon: 'ğŸ¥£', timed: false },
        { name: 'ëƒ‰ë™', icon: 'ğŸ§Š', timed: true, duration: 3000 }
      ],
      CUSTOMER_TYPES: [
        { type: 'solo', count: 1, orderMin: 1, orderMax: 1, weight: 30 },
        { type: 'couple', count: 2, orderMin: 1, orderMax: 2, weight: 25 },
        { type: 'family', count: 4, orderMin: 2, orderMax: 4, weight: 20 },
        { type: 'bigFamily', count: 6, orderMin: 3, orderMax: 6, weight: 15 },
        { type: 'group', count: 10, orderMin: 5, orderMax: 10, weight: 8 },
        { type: 'bigGroup', count: 12, orderMin: 6, orderMax: 12, weight: 2, rare: true }
      ],
      DAYS: ['ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† ', 'ì¼'],
      DAY_SCHEDULE: {
        'ì›”': { am: { min: 1, max: 2 }, pm: { min: 1, max: 2 } },
        'í™”': { am: { min: 2, max: 3 }, pm: { min: 1, max: 2 } },
        'ìˆ˜': { am: { min: 2, max: 3 }, pm: { min: 2, max: 3 } },
        'ëª©': { am: { min: 1, max: 2 }, pm: { min: 1, max: 2 } },
        'ê¸ˆ': { am: { min: 1, max: 1 }, pm: { min: 2, max: 3 } },
        'í† ': { am: { min: 0, max: 0 }, pm: { min: 0, max: 0 } },
        'ì¼': { am: { min: 0, max: 0 }, pm: { min: 0, max: 0 } }
      },
      MENU_PROBABILITY: {
        am: { kadaif: 30, lemon: 50, grapefruit: 20 },
        pm: { kadaif: 60, lemon: 25, grapefruit: 15 }
      }
    };

    let GameState = {
      currentDay: 0,
      currentPeriod: 'am',
      money: 0,
      customerQueue: [],
      currentCustomer: null,
      cookingSlots: [],
      stats: { goodCount: 0, badCount: 0, dayMoney: 0, dayGood: 0, dayBad: 0 },
      bigGroupAppeared: false,
      slotIdCounter: 0
    };

    function random(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function weightedRandom(items, weightKey) {
      const totalWeight = items.reduce((sum, item) => sum + item[weightKey], 0);
      let rand = Math.random() * totalWeight;
      for (const item of items) {
        rand -= item[weightKey];
        if (rand <= 0) return item;
      }
      return items[items.length - 1];
    }

    function getMenuByProbability(period) {
      const probs = CONFIG.MENU_PROBABILITY[period];
      const rand = Math.random() * 100;
      if (rand < probs.kadaif) return 'kadaif';
      if (rand < probs.kadaif + probs.lemon) return 'lemon';
      return 'grapefruit';
    }

    function showNotification(message) {
      document.getElementById('notification-bar').textContent = 'ğŸ”” ' + message;
    }

    function showResultToast(type) {
      const toast = document.createElement('div');
      toast.className = 'result-toast ' + type;
      toast.textContent = type === 'good' ? 'ğŸ‘ Good! +5ì›' : 'ğŸ‘ Bad!';
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 800);
    }

    function generateCustomers() {
      const day = CONFIG.DAYS[GameState.currentDay];
      const schedule = CONFIG.DAY_SCHEDULE[day][GameState.currentPeriod];
      if (schedule.max === 0) return;

      const customerCount = random(schedule.min, schedule.max);
      for (let i = 0; i < customerCount; i++) {
        const customer = createCustomer();
        if (customer) GameState.customerQueue.push(customer);
      }

      if (GameState.customerQueue.length > 0) {
        showNotification(`${GameState.customerQueue.length}íŒ€ì˜ ì†ë‹˜ì´ ëŒ€ê¸° ì¤‘!`);
      }
      renderCustomerQueue();
    }

    function createCustomer() {
      let availableTypes = CONFIG.CUSTOMER_TYPES.filter(t => !(t.rare && GameState.bigGroupAppeared));
      const type = weightedRandom(availableTypes, 'weight');
      if (type.rare) GameState.bigGroupAppeared = true;

      const orderCount = random(type.orderMin, type.orderMax);
      const orders = [];
      for (let i = 0; i < orderCount; i++) {
        orders.push({
          id: Date.now() + '-' + i + '-' + Math.random(),
          menu: getMenuByProbability(GameState.currentPeriod),
          status: 'pending'
        });
      }

      return { id: Date.now() + '-' + Math.random(), type: type.type, count: type.count, orders };
    }

    function renderCustomerQueue() {
      const container = document.getElementById('customer-queue');
      container.innerHTML = '';

      if (GameState.customerQueue.length === 0) {
        container.innerHTML = '<div class="empty-message">ëŒ€ê¸° ì†ë‹˜ ì—†ìŒ</div>';
        renderOrderList();
        return;
      }

      GameState.customerQueue.forEach((customer, index) => {
        const div = document.createElement('div');
        div.className = 'customer-item' + (GameState.currentCustomer === index ? ' selected' : '');
        const icons = 'ğŸ‘¤'.repeat(Math.min(customer.count, 5)) + (customer.count > 5 ? `+${customer.count - 5}` : '');
        const pendingOrders = customer.orders.filter(o => o.status === 'pending').length;
        div.innerHTML = `<div class="customer-icons">${icons}</div><div class="customer-info"><div>${customer.count}ëª…</div><div>ë‚¨ì€ ì£¼ë¬¸: ${pendingOrders}</div></div>`;
        div.onclick = () => selectCustomer(index);
        container.appendChild(div);
      });
      renderOrderList();
    }

    function renderOrderList() {
      const container = document.getElementById('order-list');
      container.innerHTML = '';

      if (GameState.currentCustomer === null || !GameState.customerQueue[GameState.currentCustomer]) {
        container.innerHTML = '<div class="empty-message">ì†ë‹˜ì„ ì„ íƒí•˜ì„¸ìš”</div>';
        return;
      }

      const customer = GameState.customerQueue[GameState.currentCustomer];
      customer.orders.forEach((order, index) => {
        const div = document.createElement('div');
        div.className = 'order-item ' + order.status;
        const menuInfo = CONFIG.MENU[order.menu];
        let statusIcon = { pending: 'â³', cooking: 'ğŸ”¥', completed: 'âœ…', failed: 'âŒ' }[order.status];
        div.innerHTML = `<span>${menuInfo.name}</span><span class="order-status">${statusIcon}</span>`;
        if (order.status === 'pending') div.onclick = () => startCooking(GameState.currentCustomer, index);
        container.appendChild(div);
      });
    }

    function renderCookingSlots() {
      const container = document.getElementById('cooking-slots');
      document.getElementById('cooking-count').textContent = `${GameState.cookingSlots.length}ê°œ ì¡°ë¦¬ì¤‘`;

      if (GameState.cookingSlots.length === 0) {
        container.innerHTML = '<div class="empty-slot-message">ì£¼ë¬¸ì„ í´ë¦­í•´ì„œ ì¡°ë¦¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”</div>';
        return;
      }

      container.innerHTML = '';
      GameState.cookingSlots.forEach(slot => {
        const div = document.createElement('div');
        div.className = 'cooking-slot active';
        div.id = 'slot-' + slot.id;

        const menuInfo = CONFIG.MENU[slot.targetMenu];
        let stepsHTML = '';
        CONFIG.STEPS.forEach((step, i) => {
          let stepClass = 'mini-step';
          if (i < slot.currentStep) stepClass += ' completed';
          else if (i === slot.currentStep) stepClass += ' active';
          else stepClass += ' disabled';
          stepsHTML += `<div class="${stepClass}" data-slot="${slot.id}" data-step="${i}">${step.icon}</div>`;
        });

        const showTopping = slot.currentStep === 3 && !slot.topping;
        const showServe = slot.currentStep >= 6;

        div.innerHTML = `
          <div class="slot-header"><span>${menuInfo.name}</span><button class="slot-cancel" onclick="cancelSlot(${slot.id})">âœ•</button></div>
          <div class="slot-steps">${stepsHTML}</div>
          <div class="slot-progress"><div class="slot-progress-fill" id="progress-${slot.id}"></div></div>
          <div class="slot-topping ${showTopping ? '' : 'hidden'}" id="topping-${slot.id}">
            <button class="mini-topping kadaif" onclick="selectSlotTopping(${slot.id}, 'kadaif')">ğŸ¥¨</button>
            <button class="mini-topping lemon" onclick="selectSlotTopping(${slot.id}, 'lemon')">ğŸ‹</button>
            <button class="mini-topping grapefruit" onclick="selectSlotTopping(${slot.id}, 'grapefruit')">ğŸŠ</button>
          </div>
          <button class="slot-serve ${showServe ? 'show' : ''}" onclick="serveSlot(${slot.id})">ğŸ« ì œê³µí•˜ê¸°</button>
        `;
        container.appendChild(div);

        div.querySelectorAll('.mini-step').forEach(stepEl => {
          stepEl.onclick = (e) => {
            e.stopPropagation();
            if (parseInt(stepEl.dataset.step) === slot.currentStep) advanceSlotStep(slot.id);
          };
        });
      });
    }

    function updateStatusBar() {
      document.getElementById('day-display').textContent = CONFIG.DAYS[GameState.currentDay] + 'ìš”ì¼';
      document.getElementById('period-display').textContent = GameState.currentPeriod === 'am' ? 'ì˜¤ì „' : 'ì˜¤í›„';
      document.getElementById('money-display').textContent = GameState.money + 'ì›';
      document.getElementById('good-display').textContent = GameState.stats.goodCount;
      document.getElementById('bad-display').textContent = GameState.stats.badCount;
    }

    function selectCustomer(index) {
      GameState.currentCustomer = index;
      renderCustomerQueue();
    }

    function startCooking(customerIndex, orderIndex) {
      if (GameState.cookingSlots.length >= CONFIG.MAX_COOKING_SLOTS) {
        showNotification('ì¡°ë¦¬ëŒ€ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!');
        return;
      }

      const customer = GameState.customerQueue[customerIndex];
      if (!customer) return;
      const order = customer.orders[orderIndex];
      if (!order || order.status !== 'pending') return;

      order.status = 'cooking';
      const slot = {
        id: ++GameState.slotIdCounter,
        customerIndex, orderIndex,
        orderId: order.id,
        targetMenu: order.menu,
        currentStep: 0,
        topping: null,
        timerStart: null,
        timerInterval: null
      };

      GameState.cookingSlots.push(slot);
      showNotification('ì¡°ë¦¬ ì‹œì‘!');
      renderOrderList();
      renderCookingSlots();
    }

    function advanceSlotStep(slotId) {
      const slot = GameState.cookingSlots.find(s => s.id === slotId);
      if (!slot) return;

      const stepConfig = CONFIG.STEPS[slot.currentStep];
      if (stepConfig.needsTopping && !slot.topping) return;

      if (stepConfig.timed && !slot.timerStart) {
        slot.timerStart = Date.now();
        slot.timerInterval = setInterval(() => updateSlotProgress(slotId), 50);
        return;
      }

      slot.currentStep++;
      slot.timerStart = null;
      if (slot.timerInterval) { clearInterval(slot.timerInterval); slot.timerInterval = null; }
      renderCookingSlots();
    }

    function updateSlotProgress(slotId) {
      const slot = GameState.cookingSlots.find(s => s.id === slotId);
      if (!slot || !slot.timerStart) return;

      const stepConfig = CONFIG.STEPS[slot.currentStep];
      const elapsed = Date.now() - slot.timerStart;
      const progress = Math.min((elapsed / stepConfig.duration) * 100, 100);

      const progressEl = document.getElementById('progress-' + slotId);
      if (progressEl) progressEl.style.width = progress + '%';

      if (elapsed >= stepConfig.duration) {
        clearInterval(slot.timerInterval);
        slot.timerInterval = null;
        slot.currentStep++;
        slot.timerStart = null;
        renderCookingSlots();
      }
    }

    function selectSlotTopping(slotId, topping) {
      const slot = GameState.cookingSlots.find(s => s.id === slotId);
      if (!slot || slot.currentStep !== 3) return;
      slot.topping = topping;
      advanceSlotStep(slotId);
    }

    function serveSlot(slotId) {
      const slot = GameState.cookingSlots.find(s => s.id === slotId);
      if (!slot || slot.currentStep < 6) return;

      const customer = GameState.customerQueue[slot.customerIndex];
      if (!customer) { removeSlot(slotId); return; }

      const order = customer.orders[slot.orderIndex];
      if (!order) { removeSlot(slotId); return; }

      const isMatch = slot.topping === order.menu;
      if (isMatch) {
        order.status = 'completed';
        GameState.money += CONFIG.MENU[order.menu].price;
        GameState.stats.goodCount++;
        GameState.stats.dayGood++;
        GameState.stats.dayMoney += CONFIG.MENU[order.menu].price;
        showResultToast('good');
      } else {
        order.status = 'failed';
        GameState.stats.badCount++;
        GameState.stats.dayBad++;
        showResultToast('bad');
      }

      removeSlot(slotId);
      updateStatusBar();
      renderOrderList();
      checkCustomerComplete(slot.customerIndex);
    }

    function cancelSlot(slotId) {
      const slot = GameState.cookingSlots.find(s => s.id === slotId);
      if (!slot) return;

      const customer = GameState.customerQueue[slot.customerIndex];
      if (customer && customer.orders[slot.orderIndex]) {
        customer.orders[slot.orderIndex].status = 'pending';
      }
      removeSlot(slotId);
      renderOrderList();
    }

    function removeSlot(slotId) {
      const index = GameState.cookingSlots.findIndex(s => s.id === slotId);
      if (index !== -1) {
        if (GameState.cookingSlots[index].timerInterval) clearInterval(GameState.cookingSlots[index].timerInterval);
        GameState.cookingSlots.splice(index, 1);
      }
      renderCookingSlots();
    }

    function checkCustomerComplete(customerIndex) {
      const customer = GameState.customerQueue[customerIndex];
      if (!customer) return;

      const pending = customer.orders.filter(o => o.status === 'pending' || o.status === 'cooking').length;
      if (pending === 0) {
        GameState.cookingSlots = GameState.cookingSlots.filter(s => s.customerIndex !== customerIndex);
        GameState.customerQueue.splice(customerIndex, 1);

        GameState.cookingSlots.forEach(slot => { if (slot.customerIndex > customerIndex) slot.customerIndex--; });

        if (GameState.currentCustomer === customerIndex) GameState.currentCustomer = null;
        else if (GameState.currentCustomer > customerIndex) GameState.currentCustomer--;

        renderCustomerQueue();
        renderCookingSlots();
        checkPeriodEnd();
      }
    }

    function checkPeriodEnd() {
      if (GameState.customerQueue.length === 0 && GameState.cookingSlots.length === 0) {
        if (GameState.currentPeriod === 'am') {
          GameState.currentPeriod = 'pm';
          showNotification('ì˜¤í›„ íƒ€ì„ ì‹œì‘!');
          updateStatusBar();
          generateCustomers();
        } else {
          endDay();
        }
      }
    }

    function endDay() { showSummary(); }

    function showSummary() {
      const day = CONFIG.DAYS[GameState.currentDay];
      document.getElementById('summary-content').innerHTML = `
        <div class="summary-item"><span>ì˜¤ëŠ˜ ìˆ˜ì…</span><span>${GameState.stats.dayMoney}ì›</span></div>
        <div class="summary-item"><span>Good</span><span>${GameState.stats.dayGood}ê°œ</span></div>
        <div class="summary-item"><span>Bad</span><span>${GameState.stats.dayBad}ê°œ</span></div>
        <div class="summary-total">ì´ ìˆ˜ì…: ${GameState.money}ì›</div>
      `;
      document.getElementById('summary-screen').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';

      const nextBtn = document.getElementById('next-day-btn');
      if (GameState.currentDay >= 6) nextBtn.textContent = 'ê²°ê³¼ ë³´ê¸°';
      else if (day === 'ê¸ˆ') nextBtn.textContent = 'ì£¼ë§ íœ´ì‹';
      else nextBtn.textContent = 'ë‹¤ìŒ ë‚ ë¡œ';
    }

    function nextDay() {
      document.getElementById('summary-screen').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';

      GameState.stats.dayMoney = 0;
      GameState.stats.dayGood = 0;
      GameState.stats.dayBad = 0;
      GameState.currentDay++;

      if (GameState.currentDay > 6) { showGameOver(); return; }

      const day = CONFIG.DAYS[GameState.currentDay];
      if (day === 'í† ' || day === 'ì¼') {
        showNotification(day === 'í† ' ? 'í† ìš”ì¼ íœ´ë¬´!' : 'ì¼ìš”ì¼ íœ´ë¬´!');
        updateStatusBar();
        setTimeout(() => showSummary(), 500);
        return;
      }

      GameState.currentPeriod = 'am';
      GameState.currentCustomer = null;
      showNotification(`${day}ìš”ì¼ ì˜¤ì „ ì‹œì‘!`);
      updateStatusBar();
      generateCustomers();
    }

    function showGameOver() {
      document.getElementById('final-stats').innerHTML = `
        <div class="final-stats">ì´ ìˆ˜ì…: ${GameState.money}ì›</div>
        <div class="final-stats">ì´ Good: ${GameState.stats.goodCount}ê°œ</div>
        <div class="final-stats">ì´ Bad: ${GameState.stats.badCount}ê°œ</div>
      `;
      document.getElementById('gameover-screen').style.display = 'block';
      document.getElementById('overlay').style.display = 'block';
    }

    function restartGame() {
      document.getElementById('gameover-screen').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('game-container').style.display = 'none';
      document.getElementById('start-screen').style.display = 'flex';
      resetGameState();
    }

    function resetGameState() {
      GameState.cookingSlots.forEach(slot => { if (slot.timerInterval) clearInterval(slot.timerInterval); });
      GameState = {
        currentDay: 0, currentPeriod: 'am', money: 0, customerQueue: [], currentCustomer: null,
        cookingSlots: [], stats: { goodCount: 0, badCount: 0, dayMoney: 0, dayGood: 0, dayBad: 0 },
        bigGroupAppeared: false, slotIdCounter: 0
      };
    }

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('game-container').style.display = 'block';
      resetGameState();
      updateStatusBar();
      renderCookingSlots();
      showNotification('ì›”ìš”ì¼ ì˜¤ì „! ê°€ê²Œ ì˜¤í”ˆ!');
      setTimeout(() => generateCustomers(), 500);
    }

    document.addEventListener('DOMContentLoaded', () => { renderCustomerQueue(); renderCookingSlots(); });
  </script>
</body>
</html>
